[快速理解-设计模式六大原则](https://www.jianshu.com/p/807bc228dbc2)

# 设计模式六大原则：

*（1）单一职责原则
*（2）开放封闭原则
*（3）里氏替换原则
*（4）依赖倒置原则
*（5）接口隔离原则
*（6）迪米特原则

## （1）单一职责原则

* 核心思想：应该有且仅有一个原因引起类的变更。
* 问题描述：假如有类 Class1 完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。
* 好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。
* 需注意：单一职责原则剔除了一个编码程序的标准，用"职责"或"变化原因"来衡量接口或类设计得是否优良，但是"职责"和"变化原因"都是不可以度量的，因项目和环境而异。

## （4）依赖倒置原则

* 核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
* 说明：高层模块就是调用端，底层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。
* 通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，实现模块间的松耦合。
* 问题描述：类A直接使用类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责负责的业务逻辑；类B和类C是底层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
* 解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。
* 好处：依赖倒置的好处在小型项目中很难体现出来，但在大中型项目中可以减少需求变化引起的工作量，使并行开发更友好。

## （5）接口隔离原则

* 核心思想：类间的依赖关系应该建立在最小的接口上
* 通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少，也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
* 需要注意：
* 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。
* 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
* 为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。

## 总结

对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，一般不会说有没有遵守，而是说遵守程度的多少，任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。

# 合规化插件 SDK 关于设计模式原则的使用

## 背景（类组件化工程）

合规化插件 SDK 工程可以看做是一个简单的组件化工程，既然是一个类组件化工程，通信上面就需要进行解耦。 通信方式：面向协议通信、面向 API 通信。
> 面向协议通信：

```json
{
  "classname": "HostEngine",
  "methodName": "getHostData",
  "routeParams": ""
}
```

> 面向API通信：类型 ARouter 拿到 Provider以后直接调用API进行通信。 宿主与插件之间通信采用的是面向API

## 背景

**`形式合规化工程`** 从实际情况出发，宿主、插件、插件 SDK 之间涉及到以下四个场景的的通信：

* 1、埋点通信
* 2、日志通信
* 3、UI通信
* 4、业务通信
* 5、其他场景通信：例如 JSON 解析

结合 **`单一职责原则`**，将上面五种场景进行细分为五个模块，每个模块只负责自己对应的场景。

## 通信方式

两种方式：面向协议、面向接口

### 面向协议

```java
public class RequestConfig {

  String className;
  String methodName;
  String routeParams;
  Object extraRequestObj;
}
```

将类，方法，参数协议化，调用方看到的只有一个通用的API。

* 优点：

> 1、扩展性强
> 2、类似 AIDL 的方式，不需要考虑方法匹配问题。调用方可以较为随意修改方法以及对应的参数。

* 缺点：

> 1、需要维护好协议文档。
> 2、调用方和接收方在处理数据时需要将 Object 转为具体的实例对象，这个地方存在风险，向下的类型强转这个工作量维护也比较大

### 面向API

* 优点： 直观，调用简单。
* 缺点： 不好扩展，需要注意方法匹配问题。

## 依赖倒置与接口隔离

对于插件Plugin 和 Plugin SDK 而言，其实只需要知道一件事情就可以了，调用了文档里面的对应的 API，就可以完成对应的事情，不需要关心里面的具体实现。

*（1）借鉴SPI的思想，构建五个 Interface 对应上面五种服务
*（2）将服务接口类Interface 下沉至插件 SDK 中
*（3）对于插件和插件 SDK 而言，只能看到五种 Interface，无法看到其具体实现
*（4）由宿主注入具体实现，结合 ABTest 以及相关策略，实现 InterfaceImpl 的动态注入
*（5）从而实现可拔插的 IOC 容器。

## 单例模式延迟加载

（）需要提前预料到，不是每一种服务都是一定会被使用到的，不同的场景不同的插件可能用到的服务并不同，已 UI 服务为例，可能有的用户在某些场景下根本不会去使用 UI 服务对应的场景，因此在对这些服务的注册上面，考虑使用延迟加载的方式，即注册已Class的方式进行注册。

（2）服务具有唯一性，虽然服务可拔插，但是这种可拔插基于服务没有被确定，服务一旦被确定，服务便不可被修改。因此构造的每一个服务都是单例的形式存在。

## 动态代理

为了提高可控性，或 SDK 的 PluginServiceLoader 中加载对象时，通过动态代理的方式为其构建一个代理对象，实现统一调度。

## 工厂模式

动态代理里面需要考虑多层继承和实现的情况，例如：

```
class A1 extend A2 implements A3
class A2 extend A4 implements A5
```

&emsp;&emsp;如果是这种情况，构建过程就比较复杂，这里使用工厂模式，将代理对象的创建和使用的过程分开。

&emsp;&emsp;在对IService进行向上查找时，用到了递归和广度遍历的迭代算法，这些代码都放在了InvocationHandler中，就导致了InvocationHandler比较臃肿，因此考虑将这些代码放到Utils中，当InvocationHandler创建ProxyObject时，调用Utils进行IService的向上查找， 更进一步的优化是
InvocationHandler其实也只是想拿到一个 ProxyObject 而已，并不想关注 Utils.getJustInterfaces 这个过程。

&emsp;&emsp;同时，Utils这个名字其他的也不太专业，不能单从类名看出其作用，因此将getJustInterfaces 和 Proxy.newProxy统一放进 DynamicProxyObjFactory类中，这样InvocationHandler便无需关心其实现过程，只负责拿到 PluginObject 就可以了。

## 门面模式

通过上面这种设计模式以后，对于插件而言，只提供 IServiceLoader 这一个类

```java
public interface IServiceLoader {

  ILogService getLogService();

  ITrackService getTrackService();

  IUiService getUiService();

  // Inter-Host-Plugin-Communication（宿主-插件间通信，目前没有插件间通信，如果存在，直接定义为IPC，P指Plugin，插件间通信可能更为合适）
  IIHPCService getIHPCService();

  IJsonService getJsonService();
}
```

## 静态代理

线上环境不允许用户直接从外部安装插件，为了避免这个问题，会采取一系列的校验措施，这些校验在代码的各个角落。

但是为了方便调试，允许在开发阶段直接从外部加载插件，这个时候的需求就是不要进行安全校验，以及一些策略控制。

### 灾难一

使用if...else在各个角落进行控制

### 灾难二

在StrategyManager内的每个方法执行前都进行if...else的判断，这个比灾难一要好一些，将判断收敛到一个类中，但是仍然有弊端，if...else只在线下有效，在线上无效。因此这代码完全就是多余的。 而且非常不利于后期维护，一旦后期有新增的策略或者需要对这个类进行更改，估计是很难下手进行修改的。

因此这里考虑使用代理的方式，根据不同的策略，构造不同的代理实现类。结构如下：

```java
public class StrategyConcrete implements IStrategy {

  private IStrategy proxy;

  public StrategyConcrete() {
    int strategy = Outer.getStrategy();
    if (strategy == 0) {
      proxy = new StrategyProxy1();
    } else if (strategy == 1) {
      proxy = new StrategyProxy2();
    }
  }
}
```

通过上面的形式，以后如果有新增策略或者需要修改逻辑时，只需要在这里进行修改即可

### 弊端

弊端就是当IStrategy变更时，需要同时变更多个 StrategyProxyImpl.

结合形式合规化插件 SDK 来说： 目前 SDK 内部用到了 json 解析，SDK 中直接引入了 gson，这样就会有以下几个问题：

* 1、增大 SDK 的体积，虽然可以通过宿主配置，在编译时，将gson版本强制统一，但是这样就有一个问题，如果Gson不同版本之间API有一些差异，就很麻烦
* 2、（1）的前提是宿主也用了同一个版本的 gson，那万一宿主没有使用 gson 或者以后有一个更好的 json 解析框架出来了怎么办呢？

方案： 参考Retrofit的方案，SDK 将 json 解析的逻辑进行抽象，具体方案由宿主去实现，好处如下：
*（1）解决了SDK包体积的问题
*（2）避免了gson版本不同的兼容性问题。
*（3）将 json 的解析实现保持与宿主同步。
*（4）方便了后期宿主的扩展性。 如何做呢？
*（1）以接口回调的方式，SDK 定义 JSON 解析的接口类，实现交给宿主。